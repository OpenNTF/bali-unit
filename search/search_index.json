{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"LotusScript Testing Framework","text":"<p>VoltScript Testing Framework is a framework for testing code written using VoltScript, the evolution of LotusScript delivered as part of HCL Volt MX Go. This framework has been adapted for LotusScript.</p> <p>There are deliberately no dependencies on any LotusScript Extensions (LSX, e.g nlsxbe.dll). None should be added, it will make it dependent on a particular implementation.</p>"},{"location":"index.html#using-in-an-nsf","title":"Using in an NSF","text":"<p>Copy the contents of the VoltScriptTesting.bss into a Script Library. Write an agent with <code>Use VoltScriptTesting</code>.</p>"},{"location":"index.html#navigating-our-site","title":"Navigating Our Site","text":"<p>The documentation is organised according to the Di\u00e1taxis framework into distinct areas:</p> <ul> <li>Tutorials contains practical tutorials into how to use VoltScroipt JSON Converter.</li> <li>How-To Guides covers how to achieve certain outcomes.</li> <li>Topic Guides help give an understanding of key concepts in VoltScript JSON Converter.</li> <li>References contain API documentation and test reports.</li> </ul>"},{"location":"howto/BeforeAfterTester.html","title":"How to Write Code to BeforeAll, BeforeEach etc","text":"<p>The full code can be found in SampleBeforeAfterTester.</p>"},{"location":"howto/BeforeAfterTester.html#beforeafter-code","title":"BeforeAfter Code","text":"<pre><code>Class IntegerIncrementBeforeAfter As AbstractCustomBeforeAfter\nSub beforeAll()\na = 0\nb = 0\nEnd Sub\nSub beforeEach()\na++\nEnd Sub\nSub afterEach()\nb++\nEnd Sub\nSub afterAll()\nPrint |a is | &amp; a &amp; |, b is | &amp; b\nEnd Sub\nEnd Class\n</code></pre> <p>This CustomBeforeAfterTester uses all four methods. The variables <code>a</code> and <code>b</code> are not declared in the class, because they are needed in the actual tests. As a result, they are declared as global private variables.</p> <p>The <code>beforeAll()</code> method starting at line 3 is only for explicit instantiation of the integers. If not explicitly set, they will be 0 anyway.</p> <p>In the <code>beforeEach()</code> method starting at line 8 we increment <code>a</code>. In the <code>afterEach()</code> method starting at line 12 we increment <code>b</code>.</p> <p>Finally, we use the <code>afterAll</code> to print out <code>a</code> and <code>b</code>.</p>"},{"location":"howto/BeforeAfterTester.html#test-code","title":"Test Code","text":"<pre><code>Dim testSuite As New TestSuite(|Custom BeforeAfter Tester|)\nDim beforeAfter As New IntegerIncrementBeforeAfter\nCall testSuite.addCustomBeforeAfter(beforeAfter)\n'a = 1, b = 0\ntestSuite.describe(|Test b is false|).assertFalse(b)\n'a = 2, b = 1\nCall testSuite.describe(|Test a equals 2|).assertEqualsInteger(2, a)\n'a = 3, b = 2\nCall testSuite.describe(|Test b equals 2 primitive|).assertEqualsPrimitive(2, b)\n'a = 4, b = 3\nDim f As Double\nf = 3.0\nCall testSuite.describe(|Test CDbl(b) = 3.0|).assertEqualsDouble(f, CDbl(b))\n'a = 5, b = 4\nDim c As Single\nc = 4\nCall testSuite.describe(|Test CSngl(b) = 4|).assertEqualsSingle(c, CSng(b))\n'a = 6, b = 5\nDim d As Long\nd = 5\nCall testSuite.describe(|Test CLng(b) = 5|).assertEqualsLong(d, CLng(b))\n'a = 7, b = 6\nDim e As Integer\ne = b + 1\nCall testSuite.describe(|Test a numeric = b + 1|).assertEqualsNumeric(e, a)\n</code></pre> <p>In line 1 we just create a TestSuite without a TestRunner, because we are only running a single test suite. In line 2 we create a instance of the custom BeforeAfter class, and in line 4 we add it to the test suite. Now we are ready to start running tests. Many of the tests are straightforward, but some deserve further comment.</p> <p>On lines 16 and 17 we create a double to pass to the <code>assertEqualsDouble()</code>. This is because we cannot just pass <code>3.0</code>. We could use <code>assertEqualsNumeric()</code>, which proxies off to <code>assertEqualsDouble()</code>, but on this occasion we're using the lower level assertion.</p> <p>Note on line 18 we compare <code>b</code>. If we were to test <code>a</code>, we would need to expect the value to be 3, not 4. This is because, although the <code>CDbl()</code> function is inside the assertion, it is executed before the assertion - and thus before the <code>beforeEach()</code> is triggered. The result of the executation passed to the assertion, at which point the <code>beforeEach()</code> will run. As a result, for ease of fourth-dimensional thinking, we just compare against the value modified in the <code>afterEach()</code> function.</p>"},{"location":"howto/Jenkins.html","title":"How to Integrate with CI/CD","text":"<p>If the test is set to output an XML file, this can be automatically picked up by your CI/CD environment, e.g. Jenkins. This needs to be set on the highest level of the hierarchy, changing the output format.</p> <p>If you are using a TestRunner, call <code>TestRunner.setOutputFormat()</code>. Otherwise, call <code>TestSuite.setOutputFormat()</code>. TestSuites assigned to a TestRunner take the same output format as the TestRunner.</p> <p>To just output an XML file, call <code>setOutputFormat(\"XML\")</code>. To output the HTML files and XML files, call <code>setOutputFormat(\"BOTH\")</code>.</p> <p>For a TestRunner, a single XML file is created that contains the XML for the TestRunner and all TestSuites allocated to it.</p> <p>If a test suite fails, ensure an error is bubbled up to the runtime, with sufficient information to identify which test or tests failed. This ensures the VoltScript Runtime process exits with an error, which notifies CI/CD that that the build should be aborted.</p>"},{"location":"howto/Standalone.html","title":"How to Write a Standalone TestSuite","text":"<p>SimpleBeforeAfterTester uses this approach.</p> <ol> <li>Add <code>Use \"TestSuite\"</code> to create a set of tests.</li> <li>Instantiate the TestSuite object, passing a name for the tests. This will be combined with the run-time timestamp for the filename of the HTML file, in format \"MyTests-20220331T123000.html\". Spaces will be removed, but no other modifications to the title - it is the developer's responsibility to ensure no invalid characters. The output location can be overridden using the <code>outputTo()</code> function.</li> </ol>"},{"location":"howto/TestRunner.html","title":"How to Aggregate Test Suites","text":"<p>There are two hierarchies:</p> <ul> <li>TestRunner for aggregating multiple test suites. The default output format is HTML. This will output multiple HTML files, one for each test suite, with an index.html to bootstrap them.</li> <li>TestSuite for creating a single test suite containing multiple tests.</li> </ul>"},{"location":"howto/TestRunner.html#testrunner","title":"TestRunner","text":"<p>Simple Example uses this approach.</p> <ol> <li>Add <code>Use \"VoltScriptTesting\"</code> to incorporate the VoltScript Testing Framework script.</li> <li>Declare a <code>New TestRunner</code> to aggregate all test suites, passing a label. This will be combined with the run-time timestamp for the directory name containing the HTML files, in format \"MyTitle-20220331T123000\". Spaces will be removed, but no other modifications to the title - it is the developer's responsibility to ensure no invalid characters, best practice is to use only alphanumeric characters. The files will be placed in the sub-directory <code>unit-test-reports</code> under the run context. The output location can be overridden using the <code>outputTo()</code> function. Changing this at the TestRunner will filter down to all TestSuites added to the TestRunner.</li> <li>For best clarity, a separate function is used for each test suite, with the test runner passed as an argument to each function.</li> <li>Instantiate a TestSuite object, passing a name for the tests. This will be used for the filename of the HTML file, in format MyTests.html. The file will be in the same directory as the index.html. Spaces will be removed, but no other modifications to the title - it is the developer's responsibility to ensure no invalid characters, best practice is to use only alphanumeric characters.</li> <li>Add the TestSuite object to the TestRunner object, using <code>MyTestRunner.addTestSuite(MyTestSuite)</code>. As an alternative to steps 5 and 6, there is a method <code>TestRunner.createTestSuite(\"Test Title\")</code>, which will return a newly-created TestSuite object.</li> </ol>"},{"location":"howto/customtester.html","title":"How to Write a Custom Tester","text":""},{"location":"howto/customtester.html#custom-class","title":"Custom Class","text":"<p>A custom tester can be used to run multiuple tests. The custom tester is a Class that extends <code>AbstractCustomTester</code>. It needs a <code>runTests()</code> function that returns a boolean.</p> <pre><code>Private Class DateTimeTester As AbstractCustomTester\nFunction runTests As Boolean\nDim dateTime As Variant\nDim mon As Integer\nCall Me.testSuite.checkStarted()\ndateTime = CDat(|30/01/2022|)\nCall checkIsDateTime(Datetime)\nmon = Month(dateTime)\ncheckMonthLessThan13(mon)\nCall Me.testSuite.describe(|Check dateTime is before Now|).assertIsLessThan(Now(), CDbl(dateTime))\nEnd Function\nEnd Class\n</code></pre> <p>This is a custom class extending <code>AbstractCustomTester</code>. The only function we need to add is <code>runTests()</code>. The function can return a boolean if successful. But here, the outer code is only interested in whether or not the TestSuite ran successfully, which the TestSuite class handles internally. So no return value is passed out of the function.</p> <p>This is the first test for the TestSuite, so on line 8, we call the <code>checkStarted</code> function of the TestSuite, which is a property of the parent class. This sets the timer for the TestSuite and, if appropriate, runs a custom <code>beforeAll()</code> function. We then call two internal functions - <code>checkIsDateTime()</code> and <code>checkMonthLessThan13()</code> and finally run an inline assertion. These are:</p> <pre><code>Function checkIsDateTime(dateTime As Variant) As Boolean\ncheckIsDateTime = Me.testSuite.describe(|Check is DateTime Variant|).assertIs(|DATE|, dateTime)\nEnd Function\nFunction checkMonthLessThan13(mon As Integer)\nTry\nCall Me.testSuite.describe(|Check month is less than 13|)\nIf (mon &lt; 13) Then\nCall Me.testSuite.addResult(True, \"\")\ncheckMonthLessThan13 = True\nElse\nCall Me.testSuite.addResult(False, \"Expected less than 13, was \" &amp; mon)\ncheckMonthLessThan13 = False\nEnd If\nCatch\nCall testSuite.addError(testSuite.getErrorMsg, GetThreadInfo(12))\nEnd Try\nEnd Function\n</code></pre> <p>The first function runs a simple assertion. The second one is more complex. A result is added (true or false), with the appropriate message. If there is an error - which should not happen in this scenario - the test is errored.</p>"},{"location":"howto/customtester.html#using-the-class","title":"Using the Class","text":"<p>Using the class is very straightforward. We create a TestSuite and an instance of the custom tester class. We then add the TestSuite to the tester and call the tester's <code>runTests()</code> function.</p> <pre><code>Dim TestSuite As New TestSuite(|DateTime Tests|)\nDim DateTimeTester As New DateTimeTester\nCall DateTimeTester.addTestSuite(TestSuite).runTests()\n</code></pre> <p>If we wished, additional tests could be run before or after calling the tester's <code>runTests()</code> function.</p>"},{"location":"howto/location.html","title":"Where to Write Your Tests","text":"<p>In experience, test suites are best written as functions in the same script as the functions they are testing. Typically we locate these at the end of the script, for clearer separation. Including the functions in the same script they are testing allows use of private variables e.g. to mock actual objects, route logic differently, write errors elsewhere etc.</p> <p>A separate unit test / integration script can be used to trigger the test functions. This typically handles errors internally to ensure all test suites are run. But if a test suite fails, an error is bubbled up to the runtime, with sufficient information to identify which test or tests failed. When tests are run from CI/CD, this ensures the VoltScript Runtime process exits with an error, which notifies CI/CD that that the build should be aborted.</p>"},{"location":"howto/mocking.html","title":"How to Mock Calls","text":""},{"location":"howto/mocking.html#how-to-mock-calls","title":"How to Mock Calls","text":"<p>Unlike other frameworks, the language engine does not permit bypassing API calls during testing. As a result, code may need to be restructured to be testable. This is not completely unique to VoltScript. In other languages there are also cases where it is better to refactor code to be more testable.</p>"},{"location":"howto/mocking.html#forcing-an-error","title":"Forcing an Error","text":"<p>Proper testing not only tests successful outcomes but also errors. Sometimes this can be done by passing invalid content into a function.</p> <pre><code>Function convertStringToInteger(passedVal as String) as Integer\nCInt(passedVal)\nEnd Function\n</code></pre> <p>This can be tested by passing a non-numeric value.</p> <p>Other times, it is less simple and errors may only occur because of invalid environmental causes. This can be mocked by setting a boolean variable, and checking for the existence of this variable in your code.</p> <pre><code>Dim FORCE_ERRORS as Boolean\nFunction doComplexProcessing()\nIf FORCE_ERRORS Then Error 1001, \"Invalid Content\"\n...\nEnd Function\n</code></pre> <p>This scenario envisages that there is a lot of additionl content for the <code>doComplexProcessing()</code> function, which uses a lot of variables set elsewhere and refactoring the code is not desirable. Setting up all those other variables is difficult in unit testing and will be covered by integration testing. But testing the error is simple, the tester can set <code>FORCE_ERRORS</code> to true and expect an error.</p> <p>Note</p> <p>Remember to reset FORCE_ERRORS afterwards.</p>"},{"location":"howto/mocking.html#creating-mock-data-inline","title":"Creating Mock Data Inline","text":"<p>An alternative approach would be to use a <code>TEST_RUN</code> boolean variable and check for it. Code can then run <code>If TEST_RUN Then Call createMockDoc()</code>, running a function to create mock data inline. Tests can set that <code>TEST_RUN</code> variable at the start of processing.</p>"},{"location":"howto/untestable-to-testable.html","title":"How to Change Functions to be Testable","text":"<p>Functions may need to be changed or written differently. It's easy to convert an example on a blog post about writing testable code for VoltScript. Imagine the following function:</p> <pre><code>Function getTimeOfDay() as String\nDim nowTime as Variant\nnowTime = Now()\nIf (Hour(Now) &lt; 8) Then\ngetTimeOfDay = \"Night\"\nElseIf (Hour(Now) &lt; 12) Then\ngetTimeOfDay = \"Morning\"\nElseIf (Hour(Now) &lt; 6) Then\ngetTimeOfDay = \"Afternoon\"\nElse\ngetTimeOfDay = \"Night\"\nEnd If\nEnd Function\n</code></pre> <p>This function is untestable, unless you are willing to test at multiple times of day or change the system time. Rewriting the function slightly can make it eminently testable:</p> <pre><code>Function getTimeOfDay(nowTime as Variant) as String\nIf (Hour(Now) &lt; 8) Then\ngetTimeOfDay = \"Night\"\nElseIf (Hour(Now) &lt; 12) Then\ngetTimeOfDay = \"Morning\"\nElseIf (Hour(Now) &lt; 6) Then\ngetTimeOfDay = \"Afternoon\"\nElse\ngetTimeOfDay = \"Night\"\nEnd If\nEnd Function\n</code></pre> <p>Now it can be tested easily:</p> <pre><code>Dim testSuite as New TestSuite(\"Testing time of day\")\nDim nowTime as Variant\nnowTime = TimeNumber(4,30,04)  ' Fine because we're only interested in the time\nCall testSuite.describe(\"Test Night am\").assertEqualsString(\"Night\", getTimeOfDay(nowTime), True)\nnowTime = TimeNumber(8,30,04)\nCall testSuite.describe(\"Test Morning\").assertEqualsString(\"Morning\", getTimeOfDay(nowTime), True)\nnowTime = TimeNumber(13,30,04)\nCall testSuite.describe(\"Test Afternoon\").assertEqualsString(\"Afternoon\", getTimeOfDay(nowTime), True)\nnowTime = TimeNumber(20,30,04)\nCall testSuite.describe(\"Test Night pm\").assertEqualsString(\"Night\", getTimeOfDay(nowTime), True)\n</code></pre>"},{"location":"howto/validation.html","title":"How to Use VoltScript Testing Framework for Validation","text":"<p>Imagine we have the following class:</p> <pre><code>Class Person\nPublic firstName as String\nPublic lastName as String\nPublic age as Integer\nSub New()\nEnd Sub\nEnd Class\n</code></pre> <p>We may want to validate that a Person has been set up correctly, because properties are not set and validated during the constructor.</p>"},{"location":"howto/validation.html#setting-up-person","title":"Setting up Person","text":"<pre><code>Dim person as New Person()\nperson.firstName = \"John\"\nperson.lastName = \"Doe\"\nperson.age = 42\n</code></pre> <p>We will create the Person and set property values, ready for validation. In reality, this might be a JSON object received or a VoltScript object pre-populated outside the script that wants to validate it.</p>"},{"location":"howto/validation.html#test-code","title":"Test Code","text":"<pre><code>Dim testSuite as New TestSuite(\"Validator\")\ntestSuite.suppressReport = True\nCall testSuite.describe(\"fname\").assertNotEqualString(\"\", person.firstName)\nCall testSuite.describe(\"lname\").assertNotEqualString(\"\", person.lastName)\nCall testSuite.describe(\"age &gt; 0\").assertIsGreaterThan(0.0, CDbl(person.age))\nCall testSuite.describe(\"age &gt; 0 alt\").assertTrue(person.age &gt; 0)\nCall testSuite.describe(\"age sensible\").assertTrue(person.age &lt; 110)\n</code></pre> <p>We need to pass a name to the TestSuite in line 1, even though it's not being used. The key is line 2, where we suppress the report. If we did not, when the code finishes and the TestSuite is deleted, the HTML reports would be generated - unnecessarily.</p> <p>In lines 3 - 8 we run the tests. Age is an integer, so could potentially be a negative integer, or much bigger than the age a person could be.</p>"},{"location":"howto/validation.html#checking-the-validation-ran","title":"Checking The Validation Ran","text":"<pre><code>If testSuite.ranSuccessfully() Then\nPrint \"Person valid\"\nElse\nerrMsg = \"Person not valid\"\nForAll test in testSuite.results\nIf (test.outcome &lt;&gt; \"Passed\") Then\nerrMsg = errMsg &amp; Chr(10) &amp; ListTag(test) &amp; \": \" &amp; test.errorMsg\nEnd If\nEnd ForAll\nError 1001, errMsg\nEnd If\n</code></pre> <p>Checking validation worked is straightforward and done by calling the <code>ranSuccessfully()</code> function in line 1. If it wasn't successful, you want to identify what went wrong. This is done in lines 5 - 9. We loop through the results, which gives us access to the TestCase object. If the outcome was not \"Passed\", we capture the reason - the TestCase's errorMsg. This would be something like \"Expected: 1, but was: 3\".</p>"},{"location":"howto/writingtests.html","title":"How to Write Tests","text":""},{"location":"howto/writingtests.html#creating-a-test","title":"Creating a Test","text":"<p>Each test needs a description. This is set by calling <code>Call TestSuite.describe(|My Test Name|)</code>. If this is omitted, the test name is \"Test \" + a unique number. Tests must be followed by an assertion. If this is accidentally forgotten, the test will fail with a \"Missing Assertion\" response.</p> <p>The <code>describe()</code> function returns the TestSuite, so the assertion can be chained onto the end of the <code>describe</code> call, e.g. <code>Call TestSuite.describe(|My Test Name|).assertTrue(True)</code>. This is recommended for better readability.</p>"},{"location":"howto/writingtests.html#assertions","title":"Assertions","text":""},{"location":"howto/writingtests.html#in-built-assertions","title":"In-Built Assertions","text":"<p>All assertion functions begin <code>assert...</code>. The in-built assertions are:</p> <ul> <li><code>assertTrue(actual as Boolean)</code> expects the expression or variable passed in is true or numeric not 0.</li> <li><code>assertFalse(actual as Boolean)</code> expects the expression or variable passed in is false or numeric 0.</li> <li><code>assertIs(expectedType as String, actual as Variant)</code> runs <code>TypeName()</code> on the actual value passed and compares its type to the expected type. For objects, this is the actual class name. For objects that are derived classes cannot be used to check if the object is an instance of a base class. For example, if you create your own custom tester class, you cannot use this to check if it is an instance of AbstractCustomTester. For best practice, pass the class name as upper case. However, internally, the code will <code>LCase()</code> both.</li> <li><code>assertIsNot(expectedType as String, actual as Variant)</code> runs the opposite test.</li> <li><code>assertEqualsString(expected as String, actual as String, caseInsensitive as Boolean)</code> expects the two strings to match. The third parameter can be used to force case-sensitive comparison. If <code>false</code> the two values are compared as lower case. This method is only intended for simple string comparisons. If pitch comparison is required, use <code>StrCompare</code> with the appropriate in-built assertion or a custom assertion function / custom tester.</li> <li><code>assertNotEqualString(expected as String, actual as String, caseInsensitive as Boolean)</code> runs the opposite test.</li> <li><code>assertEqualsDouble(expected as Double, actual as Double)</code> expects two doubles to match, running <code>CStr()</code> to avoid bit-level issues.</li> <li><code>assertNotEqualDouble(expected as Double, actual as Double)</code> runs the opposite test.</li> <li><code>assertEqualsInteger(expected as Integer, actual as Integer)</code> expects two integer to match.</li> <li><code>assertNotEqualInteger(expected as Integer, actual as Integer)</code> runs the opposite test.</li> <li><code>assertEqualsLong(expected as Long, actual as Long)</code> expects two longs to match, running <code>CStr()</code> to avoid bit-level issues.</li> <li><code>assertNotEqualLong(expected as Long, actual as Long)</code> runs the opposite test.</li> <li><code>assertEqualsSingle(expected as Single, actual as Single)</code> expects two singles to match, running <code>CStr()</code> to avoid bit-level issues.</li> <li><code>assertNotEqualSingle(expected as Single, actual as Single)</code> runs the opposite test.</li> <li><code>assertEqualsNumeric(expected as Variant, actual as Variant)</code> expects two numeric values to match, running <code>CStr()</code> to avoid bit-level issues.</li> <li><code>assertNotEqualNumeric(expected as Variant, actual as Variant)</code> runs the opposite test.</li> <li><code>assertIsBetween(expected1 as Double, expected2 as Double, actual as Double)</code> expects the actual to be greater than or equal to the first expected value and less than or equal to the second. This runs \"between\", not \"strictly between\". If you want to run a \"strictly between\" test, use <code>assertTrue()</code> or <code>assertFalse()</code> withg an expression, or a custom tester.</li> <li><code>assertIsGreaterThan(expected as Double, actual as Double)</code> expects the actual to be greater than the expected value.</li> <li><code>assertIsLessThan(expected as Double, actual as Double)</code> expects the actual to be less than the expected value.</li> <li><code>assertEqualsPrimitive(expected as Variant, actual as Variant)</code> expects the two variables to match, ignoring data type and CStr-ing the values. So \"1\" and 1 will be considered equal, but \"One\" and \"one\" will not.</li> <li><code>assertEqualsPrimitiveOrPrimitiveArray(expected as Variant, actual as Variant)</code> expects the two variables to match, running <code>assertEqualsPrimitive()</code> on each variable or array element. If one is an array and the other is not, the assertion will fail. If both are arrays, each element will be compared with the element at the same index.</li> </ul> <p>All in-built assertions have error handling in-built and will give a full stack trace for VoltScript. Each assertion returns a true / false for success, which can be utilised, if required.</p> <p>For more details of classes etc in use, see API Documentation.</p>"},{"location":"howto/writingtests.html#custom-assertions","title":"Custom Assertions","text":"<p>If an assertion is required beyond the basic options, this can be achieved by performing a function on the appropriate variables and passing the result of the function to an <code>assertTrue()</code> or <code>assertFalse()</code>.</p> <p>In simple cases this can be done inline. When doing so, be aware that an error in the function call (e.g. <code>CDbl</code> on a non-numeric value) will abort processing before the assertion is run. If more processing is required than can be done in a single function call, conditional processing can be used.</p> <pre><code>Dim dateVal as Variant\nTry\nCall testSuite.describe(|Check month is less than 13|)\ndateVal = CDat(passedVal)\nIf (Month(dateVal) &lt; 13) Then\nIf (Day(dateVal) &lt; 32) Then\nIf (Year(dateVal) &gt; 1900 And Year(dateVal) &lt; 2000)\nCall testSuite.addResult(True, \"\")\nElse\nCall testSuite.addResult(False, \"Expected between 1900 and 2000, was \" &amp; Year(dateVal))\nElse\nCall testSuite.addResult(False, \"Expected less than 31, was \" &amp; Day(dateVal))\nEnd If\nElse\nCall testSuite.addResult(False, \"Expected less than 13, was \" &amp; Month(dateVal))\nEnd If\nCatch\nCall testSuite.addError(Error() &amp; \" on \" &amp; Erl(), GetThreadInfo(12))\nEnd Try\n</code></pre> <p>This code expects a date string to be passed (<code>passedVal</code>, used in line 4). Rather than running multiple assertions checking various aspects of the date, it runs various conditional statements, failing the test if any part fails, succeeding if all conditionals are true, and adding an error on line 18 if the date conversion fails.</p> <p>In other scenarios, a custom function that returns a boolean may be more appropriate, with an assertion on the result.</p> <p>In very complex cases, a custom tester class can be used.</p> <p>If you have custom before/after code for tests, remember to call <code>TestSuite.runBeforeEach()</code> before running your test and <code>TestSuite.runAfterEach()</code> at the end.</p>"},{"location":"howto/writingtests.html#custom-assertions-as-first-test","title":"Custom Assertions as First Test","text":"<p>In-built assertions will always call <code>checkStarted()</code> at the start. This runs the <code>beforeAll()</code> function of a AbstractCustomBeforeAfter class passed in. If your first test is not a built-in assertion, you will need to call <code>TestSuite.checkStarted()</code> first.</p>"},{"location":"howto/writingtests.html#testsuite-pass-fail","title":"TestSuite Pass / Fail","text":"<p>After all tests have been run, the TestSuite has a <code>ranSuccessfully()</code> function that returns a boolean to identify if all tests ran successfully. If you want to access the results, these are in a <code>results</code> List, where the label is the test name (corrected as appropriate for uniqueness).</p>"},{"location":"references/index.html","title":"References","text":"<p>Note</p> <p>The sample unit test output includes errors. These are not unit tests for the unit testing framework, they are samples to show the full range of output options, including failing tests, missing assertions etc.</p>"},{"location":"references/index.html#repository-structure","title":"Repository Structure","text":"<ul> <li>All the required code itself is in src/VoltScriptTesting.bss.</li> <li>Tests are in test directory. Output will be written to unit-test-reports directory.</li> <li>A starter for writing your own tests is in assets/example_code/TestBootstrap.bss.</li> </ul>"},{"location":"references/index.html#api-documentation","title":"API Documentation","text":"<ul> <li>VoltScript Testing Framework Class Documentation</li> </ul>"},{"location":"references/index.html#unit-test-output","title":"Unit Test Output","text":"<ul> <li>Basic Tester</li> <li>Basic Tester XML output</li> <li>Custom Before/After Tester</li> <li>DateTime Tester</li> </ul>"},{"location":"references/index.html#unit-tests","title":"Unit Tests","text":"<ul> <li>Basic Tester</li> <li>SampleBeforeAfterTester</li> <li>SampleCustomTester</li> <li>TestBootstrap</li> </ul>"},{"location":"references/CoreFunctions.html","title":"Core Language Functions Used","text":"<p>Core Functions in VoltScriptTesting.bss</p> <p><code>%REM</code> and <code>%END REM</code> are used throughout. <code>'</code> for a single-line comment is also used.</p> <p>When listing keywords, sub/function names where the keyword is used are in brackets. Sub/function location is not used for common functions, datatypes or As.</p> <p>In Declarations the following language keywords are used:</p> <ul> <li>Type</li> <li>End Type</li> <li>As</li> <li>String</li> <li>Const</li> </ul>"},{"location":"references/CoreFunctions.html#private-makedirsbaliunit-function","title":"Private makeDirsBaliUnit Function","text":"<p>This is a function to create directories in a managed way.</p> <p>Language keywords used:</p> <ul> <li>Sub</li> <li>End Sub</li> <li>As</li> <li>String</li> <li>On Error GoTo</li> <li>MkDir</li> <li>CurDir</li> <li>Exit Sub</li> <li>If...Then</li> <li>End If</li> <li>Err</li> <li>Error</li> <li>MsgBox</li> <li>Cstr</li> <li>Erl</li> <li>Resume Next</li> </ul>"},{"location":"references/CoreFunctions.html#private-formattimeforoutput-function","title":"Private FormatTimeForOutput Function","text":"<p>This is a function to format a date variable.</p> <p>Language keywords used:</p> <ul> <li>Function</li> <li>End Function</li> <li>As</li> <li>Variant</li> <li>String</li> <li>Format(Variant of Date Type, String format). String format is <code>yymmddThhnnss</code></li> </ul>"},{"location":"references/CoreFunctions.html#abstractcustombeforeafter","title":"AbstractCustomBeforeAfter","text":"<p>This is an abstract class and contains no code.</p> <p>Language keywords used:</p> <ul> <li>Class</li> <li>End Class</li> <li>Sub</li> <li>End Sub</li> </ul>"},{"location":"references/CoreFunctions.html#abstractcustomtester","title":"AbstractCustomTester","text":"<p>This is a basic class with minimal code.</p> <p>Language keywords used:</p> <ul> <li>Class</li> <li>End Class</li> <li>Public</li> <li>As</li> <li>Sub</li> <li>End Sub</li> <li>New</li> <li>Function</li> <li>End Function</li> <li>Set (addTestSuite)</li> <li>Me (addTestSuite)</li> <li>Boolean</li> <li>Error (runTests)</li> </ul>"},{"location":"references/CoreFunctions.html#testrunner","title":"TestRunner","text":"<p>This is the class for outputting a number of HTML files, with an index.html wrapping them.</p> <p>Language keywords used:</p> <ul> <li>Class</li> <li>End Class</li> <li>Private</li> <li>Public</li> <li>As</li> <li>List</li> <li>String</li> <li>Variant</li> <li>Sub</li> <li>End Sub</li> <li>New</li> <li>Me</li> <li>Now</li> <li>Delete</li> <li>Call</li> <li>Erase (Delete)</li> <li>Right</li> <li>FullTrim</li> <li>And</li> <li>Set</li> <li>Replace (getFilePath, printoutReport)</li> <li>Integer</li> <li>On Error GoTo (printoutReport)</li> <li>FreeFile (printoutReport)</li> <li>Open (printoutReport)</li> <li>For Output As (printoutReport)</li> <li>Forall...In (printoutReport)</li> <li>End ForAll (printoutReport)</li> <li>Dim (printoutReport)</li> <li>If...Then (printoutReport)</li> <li>ElseIf (printoutReport)</li> <li>Else (printoutReport)</li> <li>End If (printoutReport)</li> <li>Cstr (printoutReport)</li> <li>Print fileNum, String (printoutReport)</li> <li>Close (printoutReport)</li> <li>MsgBox (printoutReport)</li> <li>Error (printoutReport)</li> <li>Err (printoutReport)</li> <li>Erl (printoutReport)</li> <li>Resume (printoutReport)</li> </ul>"},{"location":"references/CoreFunctions.html#testsuite","title":"TestSuite","text":"<p>This is the class for a set of tests.</p> <p>Language keywords used:</p> <ul> <li>Class</li> <li>End Class</li> <li>Public</li> <li>As</li> <li>String</li> <li>Private</li> <li>Integer</li> <li>List</li> <li>Double</li> <li>Boolean</li> <li>Variant</li> <li>Sub</li> <li>End Sub</li> <li>New</li> <li>Me</li> <li>Function</li> <li>End Function</li> <li>Variant</li> <li>Set</li> <li>Delete</li> <li>Now (Delete, checkStarted)</li> <li>On Error GoTo (Delete)</li> <li>If...Then (Delete, checkStarted, convertErrorStack, runBeforeEach, runAfterEach, various assertions)</li> <li>Else (Delete, convertErrorStack, various assertions)</li> <li>End If (Delete, checkStarted, runBeforeEach, runAfterEach, various assertions)</li> <li>Not (Delete, checkStarted, convertErrorStack, runBeforeEach, runAfterEach, various assertions)</li> <li>Is Nothing (Delete, checkStarted, runBeforeEach, runAfterEach)</li> <li>Dim</li> <li>Format(Variant of Date Type, String format). String format is <code>yymmddThhnnss</code> (Delete)</li> <li>Now (Delete)</li> <li>Call</li> <li>Exit Sub (Delete)</li> <li>MsgBox (Delete)</li> <li>Error (Delete)</li> <li>Err (Delete)</li> <li>Erl (Delete)</li> <li>CStr</li> <li>Resume (Delete, assertEqualsPrimitive)</li> <li>While (makeDescriptionUnique)</li> <li>Wend (makeDescriptionUnique)</li> <li>IsElement (makeDescriptionUnique)</li> <li>True (checkStarted, various assertions)</li> <li>* (checkStarted)</li> <li>- (checkStarted)</li> <li>Right</li> <li>FullTrim</li> <li>And</li> <li>Round (duration)</li> <li>IsArray (convertErrorStack, assertNotEqualPrimitiveOrPrimitiveArray, testArrays)</li> <li>For...To (convertErrorStack, processArray, assertNotEqualPrimitiveOrPrimitiveArray)</li> <li>Next (convertErrorStack, processArray, assertNotEqualPrimitiveOrPrimitiveArray)</li> <li>UBound (convertErrorStack, processArray, assertNotEqualPrimitiveOrPrimitiveArray, testArrays)</li> <li>False (various assertions)</li> <li>= (various assertions)</li> <li>&lt;&gt; (various assertions)</li> <li>LCase (assertEqualsString, assertIs, assertIsNot)</li> <li>Long (assertEqualsLong, assertNotEqualLong)</li> <li>Single (assertEqualsSingle, assertNotEqualSingle)</li> <li>IsNumeric (assertEqualsNumeric, assertNotEqualNumeric)</li> <li>CDbl (assertEqualsNumeric, assertNotEqualNumeric, assertEqualsPrimitive)</li> <li>TypeName (assertIs, assertIsNot, assertEqualsPrimitive, assertNotEqualPrimitiveOrPrimitiveArray)</li> <li>On Error ErrNum GoTo (assertEqualsPrimitive)</li> <li>Select (assertEqualsPrimitive)</li> <li>End Select (assertEqualsPrimitive)</li> <li>CBool (assertEqualsPrimitive)</li> <li>CInt (assertEqualsPrimitive)</li> <li>CLng (assertEqualsPrimitive)</li> <li>CSng (assertEqualsPrimitive)</li> <li>Exit Function (assertEqualsPrimitive)</li> <li>ReDim Preserve (processArray)</li> <li>Join (processArray, assertNotEqualPrimitiveOrPrimitiveArray, testArrays)</li> <li>FullTrim (addResult, addError)</li> </ul>"},{"location":"references/CoreFunctions.html#testsuitereport","title":"TestSuiteReport","text":"<p>This is the class for writing out an HTML file for a TestSuite.</p> <p>Language keywords used:</p> <ul> <li>Class</li> <li>End Class</li> <li>Private</li> <li>As</li> <li>String</li> <li>Sub</li> <li>End Sub</li> <li>New</li> <li>If...Then (New, printoutReport)</li> <li>Else (New)</li> <li>End If (New, printoutReport)</li> <li>Me</li> <li>Dim (printoutReport)</li> <li>String arrays (printoutReport)</li> <li>Integer</li> <li>On Error GoTo (printoutReport)</li> <li>Forall...In (printoutReport)</li> <li>End ForAll (printoutReport)</li> <li>CStr (printoutReport)</li> <li>FreeFile (printoutReport)</li> <li>Call</li> <li>Replace (printoutReport)</li> <li>Open (printoutReport)</li> <li>For Output As (printoutReport)</li> <li>Print (printoutReport)</li> <li>Close (printoutReport)</li> <li>Exit Sub</li> <li>MsgBox (printoutReport)</li> <li>Error (printoutReport)</li> <li>Err (printoutReport)</li> <li>Erl (printoutReport)</li> <li>Resume (printoutReport)</li> </ul>"},{"location":"references/FAQs.html","title":"FAQs","text":""},{"location":"references/FAQs.html#how-do-i-use-it-in-an-nsf","title":"How do I use it in an NSF?","text":"<p>Copy the contents of the VoltScriptTesting.bss into a Script Library. Write an agent with <code>Use VoltScriptTesting</code>.</p>"},{"location":"references/FAQs.html#where-do-i-find-the-output","title":"Where do I find the output?","text":"<p>The output will, by default, be in a \"unit-test-reports\" directory (defined by the <code>BASE_REPORT_LOC</code> constant in TestRunner.bss) under the directory of the program running the tests.</p> <p>If running from a Notes Client, this is the Notes program directory. If running in a scheduled agent, this is the Domino program directory.</p>"},{"location":"references/FAQs.html#how-do-i-change-the-output-directory","title":"How do I change the output directory?","text":"<p>If you wish to change the output directory for every test runner using the script, change the <code>BASE_REPORT_LOC</code> constant.</p> <p>If you wish to change the output directory for a single set of tests:</p> <ul> <li>If using a TestRunner, call <code>TestRunner.outputTo()</code>.</li> <li>If just using a TestSuite independent of a test runner, call <code>TestSuite.outputTo()</code>.</li> </ul>"},{"location":"references/FAQs.html#why-is-the-content-outside-the-nsf","title":"WHy is the content outside the NSF?","text":"<p>The output is part of your project reporting. Typically in software development project reporting is not included in the binary deliverable, so it doesn't make sense to include in the NSF being delivered to the customer or end user. HTML is also a more flexible medium for reproducing the kind of output and user experience familiar to developers who have used JUnit.</p>"},{"location":"references/FAQs.html#what-are-missing-assertions","title":"What are missing assertions?","text":"<p>This means you have called <code>describe()</code> but a corresponding assertion - or call to <code>addResult()</code> or <code>addError()</code> - has not been included. This could be because other code after the <code>describe()</code> call has generated an error and needs fixing.</p>"},{"location":"references/FAQs.html#i-am-using-a-custombeforeafter-but-the-assertion-is-not-taking-into-account-the-value-from-the-beforeeach","title":"I am using a CustomBeforeAfter, but the assertion is not taking into account the value from the beforeEach()","text":"<p>Make sure your code is not running a function that modifies a value being modified in the beforeEach, e.g. <code>assertEqualsDouble(f, CDbl(a))</code>, where <code>a</code> is incremented in the <code>beforeEach()</code>. In the above line, the order of processing would be:</p> <ol> <li>CDbl(a)</li> <li>Call to assertion.</li> <li>Run <code>beforeEach()</code>, incrementing a.</li> <li>Run assertion.</li> </ol> <p>If the <code>beforeEach()</code> is a pure function - i.e. it just instantiates dummy data and does not modify any global variables - you could manually call <code>beforeEach()</code> before modifying the value that you are passing into the assertion. Alternatively. just compare against the value before the <code>beforeEach()</code> has run.</p>"},{"location":"references/FAQs.html#what-is-recommended-best-practice-for-test-suites","title":"What is Recommended Best Practice for Test Suites?","text":"<p>In personal experience, creating a separate function for each TestSuite gives greatest clarity. It also allows aborting a run if a key TestSuite fails. Each TestSuite is usually designed to test a specific process or self-contained aspect of the code or application.</p> <p>TestSuites for unit tests and integration tests are typically also separated. Unit tests are used to test functions that do not depend on specific environmental aspects - specific users, specific data etc. In other technologies, unit tests will also include mocking.</p> <p>Integration tests are used to test code that requires specific data to be available, specific user access to be in place, real-world testing of external systems etc.</p>"},{"location":"references/FAQs.html#how-can-we-mock-data-or-users","title":"How Can We Mock Data or Users?","text":"<p>Before/After code can create data specifically for testing - these would then become integration tests.</p> <p>Java has Mockito framework, because sub-classing is always possible and API calls can be intercepted. That is not an option here. From experience, TestSuite functions are best written in the same file as the functions being tested. The same approach is used for Rust and has the added benefit of documenting how the functions are intended to be used.</p> <p>If non-LSX custom classes are used as parameters, this may allow sub-classing with a mocked object to test a complete function. More commonly, branching logic needs to be added to the functions to route differently if the callee is a test. If the tests are in the same file as the functions being called, private variables can be used to determine if a test is being run or determine if an error should be thrown.</p>"},{"location":"references/FAQs.html#testing-means-i-have-to-write-my-functions-differently","title":"Testing Means I Have to Write My Functions Differently","text":"<p>Yes, it probably will. Writing code is one thing, writing testable code is a completely different beast, and not specific to any one language. It's not hard to find articles written about this.</p>"},{"location":"topicguides/aims.html","title":"Aims for the Framework","text":"<ol> <li>Make it easy to write terse, clear, readable tests.</li> <li>Support unit testing and integration testing.</li> <li>Minimise regression bugs.</li> <li>Generate project documentation.</li> <li>Integrate with CI/CD processes.</li> <li>Provide the most commonly used assertions, but not overwhelm with variations.</li> <li>Provide flexibility for standing up and tearing down data around tests.</li> <li>Provide intuitive coding structures.</li> <li>Provide a pleasurable coding experience.</li> </ol>"},{"location":"topicguides/approach.html","title":"Challenges","text":""},{"location":"topicguides/approach.html#beforeafter-functions-no-lambdas","title":"Before/After Functions: No Lambdas","text":"<p>VoltScript does not have the concept of anonymous functions or lambdas. So code cannot be passed to a <code>beforeAll()</code> function. But developers will need to run code before / after individual tests or all tests.</p> <p>So how do we enable this?</p> <p>The approach was one used for a previous HCL open source project, Volt MX LotusScript Toolkit, and used in other VoltScript projects: to use an abstract class which specific functions that should be overridden.</p> <p>The <code>AbstractCustomBeforeAfter</code> class provides the template for this. Rather than modify this class in the VoltScriptTesting.bss module every time, developers are expected to create a derived class that extends <code>AbstractCustomBeforeAfter</code>. Then override the relevant functions. In the test code, create an instance of the class and pass it to the TestSuite. The TestSuite can then call the functions.</p>"},{"location":"topicguides/approach.html#mocking-code","title":"Mocking Code","text":"<p>VoltScript Extension classes and core functions cannot be extended. So whereas other languages can create a mock class, that cannot be done in VoltScript. And it's not possible to re-route the language functions to alternate code during a test run.</p> <p>The approach is one similar to the Rust language, namely to include tests in the same VoltScript library module (.bss). This allows you to use private variable (e.g. FORCE_ERROR, RUN_TESTS) to identify if tests are running or if you want to force an error, and put specific code in your functions accordingly.</p> <p>You may also need to change the way your functions are written so objects are passed in. That allows a unit or integration test to create those objects outside of the function, and test the result based upon different objects.</p>"},{"location":"topicguides/approach.html#identifying-tests","title":"Identifying Tests","text":"<p>VoltScript cannot use annotations, so there's not a way to identify unit or integration test functions in a way that the VoltScript runtime can automatically identify. The idiom is to add your tests at the end of the VoltScript library module.</p>"},{"location":"tutorials/1-simple.html","title":"Simple Example","text":"<p>This simple example creates a TestRunner with two TestSuites. It outputs HTML reports.</p> <ol> <li>Add the \"VoltScriptTesting.bss\" script to your project directory. The best practice structure for the project directory will be <code>src</code> directory for main runnable scripts, <code>libs</code> directory for VoltScript dependencies and <code>test</code> for unit and integration test runnable scripts. in this structure, \"VoltScripttesting.bss\" would go into <code>libs</code>.</li> <li>Create a .bss script file in <code>test</code>.</li> <li>Add <code>Use \"../libs/VoltScriptTesting\"</code> at the top. This navigates up a directory, across to the \"libs\" directory and down to the VoltScriptTesting.bss within it. Your <code>Use</code> statement should not include the .bss suffix.</li> <li>Best practice options settings to add are <code>Option Declare</code>. You can also add <code>Option Public</code> to make all methods and classes public by default.</li> <li>Add a <code>Sub Initialize</code> and its closing <code>End Sub</code> statement.</li> <li>Within the Sub Initialize, add the following code.</li> </ol> <pre><code>Dim testRunner As New TestRunner(\"Sample Tests\")\nDim testSuite1 As New TestSuite(\"Test Suite 1\")\nDim testSuite2 As New TestSuite(\"Test Suite 2\")\nDim x as Integer\nCall testRunner.addTestSuite(testSuite1)\nCall testSuite1.describe(\"Test x = False\").assertFalse(x)\nx = -1\nCall testSuite1.describe(\"Test x = True\").assertTrue(x)\nCall testRunner.addTestSuite(testSuite2)\nCall testSuite2.describe(\"Test x = -1\").assertEqualsInteger(-1,x)\nCall testSuite2.describe(\"Test x less than 0\").assertIsLessThan(0, x)\n</code></pre> <p>In line 1 we create a TestRunner to hold our tests. In lines 2 and 3 we create two test suites.</p> <p>In line 6 we add the first TestSuite to the test runner. Then in the following lines we add tests. <code>describe()</code> is a fluent function that returns the testSuite1 variable. So we can call <code>describe()</code> and the subsequent assertion on the same line. Here we just use a basic boolean assertion.</p> <p>In line 11 we add the second TestSuite to the test runner. In line 12 we use an integer assertion and in line 13 assert that x is less than 0. Note that when using other numeric assertions and literal values, you may need to use the relevant conversion function (e.g. <code>CLng()</code>).</p> <p>When using assertions that take an expected value, the order is always <code>expected</code> as the first parameter and <code>actual</code> as the second.</p> <p>You can now run the code.</p> <p>Note</p> <p>The test results will be generated to a unit-test-reports directory in the runtime directory. If running from the command line, this will be the current directory. If running from Visual Studio Code, it will be the directory open in VS Code.</p> <p>A more thorough example can be found in BasicTester.</p>"},{"location":"tutorials/2-engage-testing.html","title":"Engage Demo - Unit Testing","text":""},{"location":"tutorials/2-engage-testing.html#setup-script-library-and-agent","title":"Setup Script Library and Agent","text":"<ol> <li>Copy VoltScriptTesting.bss into a Script Library, calling it \"VoltScriptTesting\".</li> <li>Create an agent called \"LotusScriptUnitTesting\".</li> <li>Set the \"Trigger\" to \"Agent list selection\".</li> <li>Set the \"Target\" to \"None\".</li> <li>In \"Options\" add <code>Use VoltScriptTesting</code>.</li> </ol>"},{"location":"tutorials/2-engage-testing.html#person-class","title":"Person Class","text":"<p>The Person class will contain firstName, lastName, age and gender. But gender will only be settable via a Property, and the Property will ensure a valid value is passed, otherwise generate an error.</p> <ol> <li>Add a class called \"Person\".</li> <li>Add three public properties:<ul> <li>firstName as String</li> <li>lastName as String</li> <li>age as Integer</li> </ul> </li> <li>Add a private property, pgender as String.</li> <li> <p>Add a property get for gender:</p> <pre><code>Property Get gender As String\ngender = Me.pgender\nEnd Property\n</code></pre> </li> <li> <p>Add a property set for gender:</p> <pre><code>Property Set gender As String\nIf (gender &lt;&gt; \"Male\" And gender &lt;&gt; \"Female\" And gender &lt;&gt; \"Other\") Then Error 1400, \"Invalid gender: Must be 'Male', 'Female' or 'Other'\"\nMe.pgender = gender\nEnd Property\n</code></pre> </li> </ol>"},{"location":"tutorials/2-engage-testing.html#test-successful-creation","title":"Test Successful Creation","text":"<p>This function will test creating a Person successfully, and validate the properties are as expected.</p> <ol> <li>Create a function called \"testBasic\", <code>Function testBasic(testRunner As TestRunner) As Boolean</code>.</li> <li>Declare a variable <code>p</code> as a new Person.</li> <li>Declare a TestSuite called <code>testSuite</code> with the name \"Testing Basic Success\".</li> <li>Add testSuite to the testRunner.</li> <li>Add error handling to trigger <code>Call testSuite.addError(\"Error: \" &amp; Error &amp; \" on line \" &amp; Erl, Erl)</code>.</li> <li>Add a test with the description \"Test creating a person\".</li> <li>Set firstName, lastName, age and a valid gender for <code>p</code>.</li> <li>Call <code>Call testSuite.addResult(True, \"\")</code>. If we get here, the test was successful.</li> <li>Add a test with the description \"Test p is a Person\".</li> <li>Add an assertion that <code>p</code> is a \"PERSON\".</li> <li>Add a test to validate the Person's name.</li> <li>Add a test to validate the Person's age.</li> <li>Add a test to validate the Person's gender.</li> <li>Exit the function by calling <code>testBasic = testSuite.ranSuccessfully()</code>.</li> </ol> Completed Function <pre><code>Function testBasic(testRunner As BaliTestRunner) As Boolean\nDim p As New Person\nDim testSuite As New TestSuite(\"Testing Basic Success\")\nCall testRunner.addTestSuite(Testsuite)\nOn Error GoTo logErr\nCall testSuite.describe(\"Test creating a person\")\np.firstName = \"Paul\"\np.lastName = \"Withers\"\np.age = 21\np.gender = \"Male\"\nCall testSuite.addResult(True, \"\")  'Successfully created a person\nCall testSuite.describe(\"Test p is a Person\").assertIs(\"PERSON\", p)\nCall testSuite.describe(\"Test name is Paul Withers\").assertEqualsString(\"Paul Withers\", p.firstName &amp; \" \" &amp; p.lastName, False)\nCall testSuite.describe(\"Test age is 21\").assertEqualsInteger(21, p.age)\nCall testSuite.describe(\"Test gender is male\").assertTrue(p.gender = \"Male\")\ntestBasic = testSuite.ranSuccessfully()\nExit Function\nlogErr:\nCall testSuite.addError(\"Error: \" &amp; Error &amp; \" on line \" &amp; Erl, Erl)\nExit Function\nEnd Function\n</code></pre>"},{"location":"tutorials/2-engage-testing.html#test-gender-validation","title":"Test Gender Validation","text":"<p>Testing success is insufficient for proper unit testing. We also need to unit test passing bad values.</p> <ol> <li>Create a function called \"testGenderValidation\", <code>Function testGenderValidation(testRunner As TestRunner) As Boolean</code>.</li> <li>Declare a variable <code>p</code> as a new Person.</li> <li>Declare a TestSuite called <code>testSuite</code> with the name \"Testing Basic Success\".</li> <li>Add testSuite to the testRunner.</li> <li>Add error handling with a label name <code>mainErr</code> to trigger <code>Call testSuite.addError(\"Error: \" &amp; Error &amp; \" on line \" &amp; Erl, Erl)</code>, resuming next.</li> <li>Add a test with the description \"Test creating a person does not accept 'Mail'\".</li> <li>Set the firstName, lastName and age of <code>p</code>.</li> <li>Add on <code>On Error</code> statement to goto a label called \"testErr\".</li> <li>Add a <code>testErr</code> block after the main error block. In the error block:<ol> <li>Call <code>Call testSuite.addResult(True, \"\")</code>.</li> <li>Call <code>Resume otherChecks</code>.</li> </ol> </li> <li>After the <code>On Error GoTo testErr</code>, set gender of <code>p</code> to \"Mail\".</li> <li>Fail the test if it gets to this line with <code>Call testSuite.addResult(False, \"Setting gender to Mail should error\")</code>.</li> <li>Add a label called <code>otherChecks</code>. We want to test all other properties after we passed the invalid gender.</li> <li>Add another <code>On Error</code> statement to go to mainErr. If any other errors occur, we want to error the test.</li> <li>Add a test with the description \"Test p is a Person\".</li> <li>Add an assertion that <code>p</code> is a \"PERSON\".</li> <li>Add a test to validate the Person's name.</li> <li>Add a test to validate the Person's age.</li> <li>Add a test to validate the Person's gender is not \"Male\".</li> <li>Exit the function by calling <code>testGenderValidation = testSuite.ranSuccessfully()</code>.</li> </ol> Completed Function <pre><code>Function testGenderValidation(testRunner As TestRunner) As Boolean\nDim p As New Person\nDim testSuite As New TestSuite(\"Testing Gender Validation\")\nCall testRunner.addTestSuite(Testsuite)\nOn Error GoTo mainErr\nCall testSuite.describe(\"Test creating a person does not accept 'Mail'\")\np.firstName = \"Paul\"\np.lastName = \"Withers\"\np.age = 21\nOn Error GoTo testErr\np.gender = \"Mail\"\nCall testSuite.addResult(False, \"Setting gender to Mail should error\")  'Successfully created a person\notherChecks:\nOn Error GoTo mainErr\nCall testSuite.describe(\"Test p is a Person\").assertIs(\"PERSON\", p)\nCall testSuite.describe(\"Test name is Paul Withers\").assertEqualsString(\"Paul Withers\", p.firstName &amp; \" \" &amp; p.lastName, False)\nCall testSuite.describe(\"Test age is 21\").assertEqualsInteger(21, p.age)\nCall testSuite.describe(\"Test gender is not male\").assertFalse(p.gender = \"Male\")\ntestGenderValidation = testSuite.ranSuccessfully()\nExit Function\nmainErr:\nCall testSuite.addError(\"Error: \" &amp; Error &amp; \" on line \" &amp; Erl, Erl)\nResume Next\ntestErr:\nCall testSuite.addResult(True, \"\")\nResume otherChecks\nEnd Function\n</code></pre>"},{"location":"tutorials/2-engage-testing.html#sub-initialize","title":"Sub Initialize","text":"<ol> <li>Declare a variable <code>testRunner</code> with the name \"Validating Person Class\".</li> <li>Declare a boolean variable called result.</li> <li>Set <code>result</code> to the result of <code>testBasic</code>, passing the <code>testRunner</code> variable.</li> <li>Set <code>result</code> to the result of <code>result</code> and <code>testGenderValidation</code>, passing the <code>testRunner</code> variable.</li> <li>If <code>result</code> is true, print \"All tests passed\"</li> </ol> Completed <pre><code>Dim testRunner As New TestRunner(\"Validating Person Class\")\nDim result As Boolean\nresult = testBasic(testRunner)\nresult = result And testGenderValidation(testRunner)\nIf result Then Print \"All test passed\"\n</code></pre> <p>Success</p> <p>You have successfully created unit tests for the Person object. Test by running the agent. The output will be written to \"unit-test-reports\" directory under the Notes program directory.</p> <p>Full Code</p> <p>Tip</p> <p>To test yourself further:</p> <ol> <li>Add unit tests for trying to pass a non-string value to <code>firstName</code> or <code>lastName</code>.</li> <li>Add a unit test for trying to pass a non-numeric value to age.</li> <li>An Integer can be a number that is not sensible for an age. Change age to a private variable and use a property to validate age is within reasonable bounds. Add tests for this.</li> </ol>"},{"location":"tutorials/3-engage-validation.html","title":"Engage Demo - Validation","text":""},{"location":"tutorials/3-engage-validation.html#form","title":"Form","text":"<ol> <li>Create a Form called \"Person\".</li> <li>Add a text field called \"FirstName\".</li> <li>Add a text field called \"LastName\".</li> <li>Add a number field called \"Age\".</li> <li>Add a radio button field called \"Gender\" and choose valid options.</li> </ol>"},{"location":"tutorials/3-engage-validation.html#globals","title":"Globals","text":"<ol> <li>In the Globals area, add <code>Option Declare</code>.</li> <li>Add `Use \"VoltScript Testing\".</li> </ol>"},{"location":"tutorials/3-engage-validation.html#querysave","title":"QuerySave","text":"<p>VoltScriptTesting can not only be used for unit / integration testing, it can also be used for validation.</p> <p>If we suppress the report, we can write unit tests to test the field values. If the tests ran successfully, the document is valid and we can continue saving. If not, we abort saving and return the test failures.</p> <ol> <li>Declare a variable <code>doc</code> as a NotesDocument.</li> <li>Set it to <code>Source.Document</code>.</li> <li>Declare a string variable called <code>errors</code>.</li> <li>Declare a boolean variable called <code>validateAge</code>.</li> <li>Add error handling to report any error and exit the sub.</li> <li>Declare a <code>testSuite</code> variable as a new TestSuite, giving it the name \"Validate Doc\". The name will not be used, but is required.</li> <li>Add a test to validate that <code>doc.FirstName(0)</code> is more than one character. <code>assertTrue</code> can be used to test the length, using <code>FullTrim()</code> and <code>Len()</code>.</li> <li>Add a test to validate that <code>doc.LastName(0)</code> is not an empty string.</li> <li>Set the boolean <code>validateAge</code> to the result of a test called \"Check age is completed\", validating the <code>CStr(doc.Age(0))</code> is not an empty String.</li> <li>If <code>validateAge</code> is true, perform three more tests.<ol> <li>Add a test to validate <code>doc.Age(0)</code> is greater than 0.</li> <li>Add a test to validate <code>doc.Age(0)</code> is less than 110.</li> <li>Add a test to validate that <code>doc.Age(0)</code> is a whole number. <code>Fraction()</code> is a LotusScript function that returns the fractional portion of a number. (For a whole number, the fractional portion should be 0.)</li> </ol> </li> <li>Add a test to validate <code>doc.Gender(0)</code> is not an empty string.</li> <li>Set <code>Continue</code> to the result of <code>testSuite.ranSuccessfully()</code>.</li> <li>If <code>continue</code> is False, add code to loop through the results and capture the descriptions for any tests that did not pass.<ol> <li>Add a <code>ForAll</code> loop to iterate over <code>testSuite.results</code>.</li> <li>For each test, check if the result is not \"Passed\". If so, Set <code>errors</code> to its existing value, the test description, and a new line.</li> <li>After the ForAll loop, <code>MsgBox</code> the errors to the user.</li> </ol> </li> </ol> <p>Success</p> <p>You have successfully added validation for the Form. If you add fields or change fields in the future, you just need to add additional tests. No other changes are needed.</p> <p>Tip</p> <p>If you have subforms and want to validate those separately, it may be preferable to move the QuerySave code to a script library. Alternatively, you could set the TestSuite as a global variable.</p> <p>Full Code</p>"}]}